* ¿Nos hemos olvidado de la transaccionalidad del Realm SQL?.

* Sistema de pagos:
  https://developer.paypal.com/docs/classic/paypal-payments-pro/\
  integration-guide/WPDirectPayment/
  
* Sistema de grabación de preparaciones:
  - http://www.html5rocks.com/en/tutorials/getusermedia/intro/
  - https://webrtc.org/
  - http://www.html5rocks.com/en/tutorials/file/filesystem/
  
* Remove (Undeploy): Vigila con las dependencias por qué si no, falla. Hacer
  borrado y creación en fases distintas.

* Seguir intentanto AJP + CLIENT-CERT
  - Estado actual:
    https://app.preparatusopos.net/certificate/authenticate
    -> 400 Bad request
    https://app.preparatusopos.net:8181/certificate/authenticate
    -> 401 Unauthorized
    Para empezar, en ambos casos debe ser "401 Unauthorized".
  - No SSL entre Apache y Glassfish
  - http://www.devwithimagination.com/2015/08/13/apache-as-a-reverse-proxy-to-glassfish/
  - https://confluence.atlassian.com/doc/using-apache-with-mod_proxy-173669.html

* Implementar manejo de errores HTTP en la aplicación WEB con
  ExceptionHandlerFactory indicado en faces-config.xml.

* Refactor: File storage (RA) -> File device (RA)

* Refactor: File y Geolocation en esquemas de BD distintos de Domain.

* Separar Geography de Geolocation
  - Geolocation entrega coordenadas a partir de entradas no estructuradas
  - Geography depende de Geolocation para establecer las coordenadas de las
    direcciones que registra.
    
* CAMBIO DE PARADIGMA EN LA INFRAESTRUCTURA (JEEMI):
  - Volver a prestigiar a JavaEE.
    Si la tendencia era ejecutar procesos de JVM en contenedores Docker con
    imágenes registradas en un registro de Docker, sustituyamos contenedor
    Docker por contenedor de aplicationes JavaEE, imagen de Docker por
    JAR/WAR/EAR/RAR... y registro de Docker por repositorio de artefactos
    (Maven?). El resto de servicios se pueden ofrecer con filosofia SaaS en
    local.
    La plataforma se crea a priori.
    La conectividad no debe ser explícita a nivel de aplicación. Cada plataforma
    dispone de un "service discovery" (JNDI?).
  - Katon (Implementation of JEEMI).
    Utiliza uno o varios servidores de aplicaciones (diversos clústers) JavaEE,
    con HA. Distintas implementaciones para distintos proveedores.
    La local levanta el servidor de aplicaciones local, implementación del cual
    está preparada para gestionar (creando los clústers e instancias HA cuando
    sea necesario), y el resto de servicios con implementación local (Como un
    gestor de base de datos PostgreSQL instalado en local).
    La de AWS crea las instancias necesarias para alojar los contenedores de
    aplicaciones necesarios, con las instancias del servidor de aplicaciones
    necesarias en cada instancia de AWS.
  - Se puede utilizar Resort como cliente, mediante la creación de componentes
    JEEMI.

