* ¿Nos hemos olvidado de la transaccionalidad del Realm SQL?.

* Sistema de pagos:
  https://developer.paypal.com/docs/classic/paypal-payments-pro/\
  integration-guide/WPDirectPayment/
  
* Sistema de grabación de preparaciones:
  - http://www.html5rocks.com/en/tutorials/getusermedia/intro/
  - https://webrtc.org/
  - http://www.html5rocks.com/en/tutorials/file/filesystem/
  
* Remove (Undeploy): Vigila con las dependencias por qué si no, falla. Hacer
  borrado y creación en fases distintas.

* Seguir intentanto AJP + CLIENT-CERT
  - Estado actual:
    https://app.preparatusopos.net/certificate/authenticate
    -> 400 Bad request
    https://app.preparatusopos.net:8181/certificate/authenticate
    -> 401 Unauthorized
    Para empezar, en ambos casos debe ser "401 Unauthorized".
  - No SSL entre Apache y Glassfish
  - http://www.devwithimagination.com/2015/08/13/apache-as-a-reverse-proxy-to-glassfish/
  - https://confluence.atlassian.com/doc/using-apache-with-mod_proxy-173669.html

* Implementar manejo de errores HTTP en la aplicación WEB con
  ExceptionHandlerFactory indicado en faces-config.xml.

* Refactor: File storage (RA) -> File device (RA)

* Refactor: File y Geolocation en esquemas de BD distintos de Domain.

* Separar Geography de Geolocation
  - Geolocation entrega coordenadas a partir de entradas no estructuradas
  - Geography depende de Geolocation para establecer las coordenadas de las
    direcciones que registra.
    
* CAMBIO DE PARADIGMA EN LA INFRAESTRUCTURA:
  - Volver a prestigiar a JavaEE.
    La tendecia es usar Java (JVM) para la lógica de dominio (con cierto grado
    de seriedad) y disponer del resto de servicios como SaaS. Además, se quiere
    disponer de sistemas de clusterización y balanceado de carga ofrecidos por
    el proveedor de infrastuctura. Y, finalmente, se quieren "containerizar"
    los procesos de JVM corrrespondientes a la lógica de dominio.
    Bien, todo esto ya lo ofrecen servidores de aplicaciones que implementan
    JavaEE y mecanismos de HA (GlassFish por ejemplo).
    Si la tendencia era ejecutar procesos de JVM en contenedores Docker con
    imágenes registradas en un registro de Docker, sustituyamos contenedor
    Docker por contenedor de aplicationes JavaEE, imagen de Docker por
    JAR/WAR/EAR/RAR... y registro de Docker por repositorio de artefactos
    (Maven?). El resto de servicios se pueden ofrecer con filosofia SaaS en
    local.
    La plataforma se crea a priori.
    La conectividad no debe ser explícita a nivel de aplicación. Cada plataforma
    dispone de un "service discovery" (JNDI?).
  - Trocola (Implementation of Java Platform Service).
    Utiliza uno o varios servidores de aplicaciones (diversos clústers) JavaEE,
    con HA. Distintas implementaciones para distintos comportamientos.
    La local levanta el servidor de aplicaciones local, implementación del cual
    está preparada para gestionar (creando los clústers e instancias HA cuando
    sea necesario), y el resto de servicios con implementación local (Como un
    gestor de base de datos PostgreSQL instalado en local).
    La de AWS crea las instancias necesarias para alojar los contenedores de
    aplicaciones necesarios, con las instancias del servidor de aplicaciones
    necesarias en cada instancia de AWS.
    Este proyecto permite definir todos los parámetros en todas las clases de
    plataforma. Actúa como cliente siempre, adaptando su entorno accesible.
    Puede ser implementado en cualquier lenguaje, aunque preferiblemente en
    Java (JVM).

